{"version":3,"sources":["components/noise.js","components/MeshAnim.js","components/Anims.js","components/math.js","components/TerrainSphere/shader/frag.js","components/TerrainSphere/shader/vert.js","components/TerrainSphere/shader/lib.js","components/TerrainSphere/TerrainSphere.js","App.js","reportWebVitals.js","index.js"],"names":["noise","Grad","x","y","z","this","prototype","dot2","dot3","grad3","p","perm","Array","gradP","seed","Math","floor","i","v","F2","sqrt","G2","G3","fade","t","lerp","a","b","simplex2","xin","yin","i1","j1","s","j","x0","y0","x1","y1","x2","y2","gi0","gi1","gi2","t0","t1","t2","simplex3","zin","k1","i2","j2","k2","k","z0","z1","z2","x3","y3","z3","gi3","t3","perlin2","X","Y","n00","n01","n10","n11","u","perlin3","Z","n000","n001","n010","n011","n100","n101","n110","n111","w","module","exports","MeshAnim","position","rotation","grid","width","height","sep","zOfXYT","colorOfXYZT","anim","init","update","mesh","useRef","useMemo","positions","colors","normals","yi","xi","push","color","r","g","Float32Array","indices","Uint16Array","posRef","colorRef","useFrame","current","array","c","needsUpdate","ref","attachObject","count","length","itemSize","attach","vertexColors","side","THREE","Terrain","random","amp","freq","sampleNoise","localRandom","PI","sin","randomSin","variation","vert","TerrainSphere","wireframe","meshRef","clock","material","uniforms","u_time","value","oldTime","args","type","rad","vertexShader","fragmentShader","CameraControls","useThree","camera","domElement","gl","controlsRef","AnimationCanvas","colorManagement","fov","fallback","extend","OrbitControls","App","className","href","alt","src","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"4EAgBA,IAAIA,EAAQ,GAEZ,SAASC,EAAKC,EAAGC,EAAGC,GAChBC,KAAKH,EAAIA,EAAGG,KAAKF,EAAIA,EAAGE,KAAKD,EAAIA,EAGrCH,EAAKK,UAAUC,KAAO,SAASL,EAAGC,GAC9B,OAAOE,KAAKH,EAAEA,EAAIG,KAAKF,EAAEA,GAG7BF,EAAKK,UAAUE,KAAO,SAASN,EAAGC,EAAGC,GACjC,OAAOC,KAAKH,EAAEA,EAAIG,KAAKF,EAAEA,EAAIE,KAAKD,EAAEA,GAGxC,IAAIK,EAAQ,CAAC,IAAIR,EAAK,EAAE,EAAE,GAAG,IAAIA,GAAM,EAAE,EAAE,GAAG,IAAIA,EAAK,GAAG,EAAE,GAAG,IAAIA,GAAM,GAAG,EAAE,GAC9D,IAAIA,EAAK,EAAE,EAAE,GAAG,IAAIA,GAAM,EAAE,EAAE,GAAG,IAAIA,EAAK,EAAE,GAAG,GAAG,IAAIA,GAAM,EAAE,GAAG,GACjE,IAAIA,EAAK,EAAE,EAAE,GAAG,IAAIA,EAAK,GAAG,EAAE,GAAG,IAAIA,EAAK,EAAE,GAAG,GAAG,IAAIA,EAAK,GAAG,GAAG,IAE7ES,EAAI,CAAC,IAAI,IAAI,IAAI,GAAG,GAAG,GAC3B,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,IAAI,IAAI,EAAE,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,IAAI,EAAE,GAAG,GAAG,IAAI,GAAG,GAAG,GACzE,IAAK,EAAE,IAAI,IAAI,IAAI,IAAI,GAAG,EAAE,GAAG,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GACzE,GAAG,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,IAAK,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,GAAG,GAAG,IACxE,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IACxE,IAAI,IAAI,GAAI,GAAG,GAAG,GAAG,IAAK,EAAE,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,IAAI,IAAK,GAAG,GAAG,IAAI,IAAI,IACxE,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,IAAK,EAAE,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,IACxE,EAAE,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,GACzE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAK,EAAE,GAAG,IAAI,IAAK,GAAG,IAAI,IAAI,IAAI,IAAI,IAAK,GAAG,IAAI,EAC1E,IAAI,GAAG,GAAG,IAAK,GAAG,GAAG,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAK,IAAI,IAAI,IAAI,IAAI,GAAG,IACxE,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,IAAK,GAAG,GAAG,IAAI,IAAI,IAAI,GAAG,IAAI,IACxE,GAAG,IAAI,IAAK,GAAG,IAAI,IAAI,IAAI,IAAI,IAAK,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAK,EAAE,IAAI,IACxE,IAAI,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,GAAG,IAAI,GAAG,IAAI,KAEhEC,EAAO,IAAIC,MAAM,KACjBC,EAAQ,IAAID,MAAM,KAItBZ,EAAMc,KAAO,SAASA,GACfA,EAAO,GAAKA,EAAO,IAEtBA,GAAQ,QAGRA,EAAOC,KAAKC,MAAMF,IACR,MACVA,GAAQA,GAAQ,GAGhB,IAAI,IAAIG,EAAI,EAAGA,EAAI,IAAKA,IAAK,CAC7B,IAAIC,EAEAA,EADI,EAAJD,EACIP,EAAEO,GAAa,IAAPH,EAERJ,EAAEO,GAAOH,GAAM,EAAK,IAG5BH,EAAKM,GAAKN,EAAKM,EAAI,KAAOC,EAC1BL,EAAMI,GAAKJ,EAAMI,EAAI,KAAOR,EAAMS,EAAI,MAI1ClB,EAAMc,KAAK,GASX,IAAIK,EAAK,IAAKJ,KAAKK,KAAK,GAAG,GACvBC,GAAM,EAAEN,KAAKK,KAAK,IAAI,EAGtBE,EAAK,EAAE,EAsJX,SAASC,EAAKC,GACV,OAAOA,EAAEA,EAAEA,GAAGA,GAAK,EAAFA,EAAI,IAAI,IAG7B,SAASC,EAAKC,EAAGC,EAAGH,GAChB,OAAQ,EAAEA,GAAGE,EAAIF,EAAEG,EAxJvB3B,EAAM4B,SAAW,SAASC,EAAKC,GAC3B,IAUIC,EAAIC,EARJC,GAAKJ,EAAIC,GAAKX,EACdF,EAAIF,KAAKC,MAAMa,EAAII,GACnBC,EAAInB,KAAKC,MAAMc,EAAIG,GACnBT,GAAKP,EAAEiB,GAAGb,EACVc,EAAKN,EAAIZ,EAAEO,EACXY,EAAKN,EAAII,EAAEV,EAIZW,EAAGC,GACNL,EAAG,EAAGC,EAAG,IAETD,EAAG,EAAGC,EAAG,GAKT,IAAIK,EAAKF,EAAKJ,EAAKV,EACfiB,EAAKF,EAAKJ,EAAKX,EACfkB,EAAKJ,EAAK,EAAI,EAAId,EAClBmB,EAAKJ,EAAK,EAAI,EAAIf,EAIlBoB,EAAM5B,GAFVI,GAAK,KAEaN,EADlBuB,GAAK,MAEDQ,EAAM7B,EAAMI,EAAEc,EAAGpB,EAAKuB,EAAEF,IACxBW,EAAM9B,EAAMI,EAAE,EAAEN,EAAKuB,EAAE,IAEvBU,EAAK,GAAMT,EAAGA,EAAGC,EAAGA,EAOpBS,EAAK,GAAMR,EAAGA,EAAGC,EAAGA,EAOpBQ,EAAK,GAAMP,EAAGA,EAAGC,EAAGA,EASxB,OAAO,KAtBJI,EAAG,EACD,GAELA,GAAMA,GACIA,EAAKH,EAAIlC,KAAK4B,EAAIC,KAGzBS,EAAG,EACD,GAELA,GAAMA,GACIA,EAAKH,EAAInC,KAAK8B,EAAIC,KAGzBQ,EAAG,EACD,GAELA,GAAMA,GACIA,EAAKH,EAAIpC,KAAKgC,EAAIC,MAQhCxC,EAAM+C,SAAW,SAASlB,EAAKC,EAAKkB,GAChC,IAeIjB,EAAIC,EAAIiB,EACRC,EAAIC,EAAIC,EAbRnB,EAlEC,mBAkEIJ,EAAIC,EAAIkB,GACb/B,EAAIF,KAAKC,MAAMa,EAAII,GACnBC,EAAInB,KAAKC,MAAMc,EAAIG,GACnBoB,EAAItC,KAAKC,MAAMgC,EAAIf,GAEnBT,GAAKP,EAAEiB,EAAEmB,GAAG/B,EACZa,EAAKN,EAAIZ,EAAEO,EACXY,EAAKN,EAAII,EAAEV,EACX8B,EAAKN,EAAIK,EAAE7B,EAMZW,GAAMC,EACNA,GAAMkB,GAAWvB,EAAG,EAAGC,EAAG,EAAGiB,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,GAC7CjB,GAAMmB,GAAMvB,EAAG,EAAGC,EAAG,EAAGiB,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,IACjCrB,EAAG,EAAGC,EAAG,EAAGiB,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,GAElDhB,EAAKkB,GAAWvB,EAAG,EAAGC,EAAG,EAAGiB,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,GAC5CjB,EAAKmB,GAAMvB,EAAG,EAAGC,EAAG,EAAGiB,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,IACjCrB,EAAG,EAAGC,EAAG,EAAGiB,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,GAMpD,IAAIf,EAAKF,EAAKJ,EAAKT,EACfgB,EAAKF,EAAKJ,EAAKV,EACfiC,EAAKD,EAAKL,EAAK3B,EAEfiB,EAAKJ,EAAKe,EAAK,EAAI5B,EACnBkB,EAAKJ,EAAKe,EAAK,EAAI7B,EACnBkC,EAAKF,EAAKF,EAAK,EAAI9B,EAEnBmC,EAAKtB,EAAK,EAAI,GACduB,EAAKtB,EAAK,EAAI,GACduB,EAAKL,EAAK,EAAI,GAMdb,EAAM5B,GAHVI,GAAK,KAGgBN,GAFrBuB,GAAK,KAE0BvB,EAD/B0C,GAAK,OAEDX,EAAM7B,EAAMI,EAAEc,EAAGpB,EAAKuB,EAAEF,EAAGrB,EAAK0C,EAAEJ,KAClCN,EAAM9B,EAAMI,EAAEiC,EAAGvC,EAAKuB,EAAEiB,EAAGxC,EAAK0C,EAAED,KAClCQ,EAAM/C,EAAMI,EAAG,EAAEN,EAAKuB,EAAG,EAAEvB,EAAK0C,EAAG,KAGnCT,EAAK,GAAMT,EAAGA,EAAKC,EAAGA,EAAKkB,EAAGA,EAO9BT,EAAK,GAAMR,EAAGA,EAAKC,EAAGA,EAAKiB,EAAGA,EAO9BT,EAAK,GAAMP,EAAGA,EAAKC,EAAGA,EAAKgB,EAAGA,EAO9BK,EAAK,GAAMJ,EAAGA,EAAKC,EAAGA,EAAKC,EAAGA,EASlC,OAAO,KA7BJf,EAAG,EACD,GAELA,GAAMA,GACIA,EAAKH,EAAIjC,KAAK2B,EAAIC,EAAIkB,KAG7BT,EAAG,EACD,GAELA,GAAMA,GACIA,EAAKH,EAAIlC,KAAK6B,EAAIC,EAAIiB,KAG7BT,EAAG,EACD,GAELA,GAAMA,GACIA,EAAKH,EAAInC,KAAK+B,EAAIC,EAAIgB,KAG7BK,EAAG,EACD,GAELA,GAAMA,GACIA,EAAKD,EAAIpD,KAAKiD,EAAIC,EAAIC,MAmBpC3D,EAAM8D,QAAU,SAAS5D,EAAGC,GAExB,IAAI4D,EAAIhD,KAAKC,MAAMd,GAAI8D,EAAIjD,KAAKC,MAAMb,GAEtCD,GAAQ6D,EAAG5D,GAAQ6D,EAKnB,IAAIC,EAAMpD,GAHVkD,GAAQ,KAGUpD,EAHLqD,GAAQ,MAGMzD,KAAKL,EAAGC,GAC/B+D,EAAMrD,EAAMkD,EAAEpD,EAAKqD,EAAE,IAAIzD,KAAKL,EAAGC,EAAE,GACnCgE,EAAMtD,EAAMkD,EAAE,EAAEpD,EAAKqD,IAAIzD,KAAKL,EAAE,EAAGC,GACnCiE,EAAMvD,EAAMkD,EAAE,EAAEpD,EAAKqD,EAAE,IAAIzD,KAAKL,EAAE,EAAGC,EAAE,GAGvCkE,EAAI9C,EAAKrB,GAGb,OAAOuB,EACHA,EAAKwC,EAAKE,EAAKE,GACf5C,EAAKyC,EAAKE,EAAKC,GACf9C,EAAKpB,KAIbH,EAAMsE,QAAU,SAASpE,EAAGC,EAAGC,GAE3B,IAAI2D,EAAIhD,KAAKC,MAAMd,GAAI8D,EAAIjD,KAAKC,MAAMb,GAAIoE,EAAIxD,KAAKC,MAAMZ,GAEzDF,GAAQ6D,EAAG5D,GAAQ6D,EAAG5D,GAAQmE,EAK9B,IAAIC,EAAO3D,GAHXkD,GAAQ,KAGapD,GAHRqD,GAAQ,KAGSrD,EAHJ4D,GAAQ,OAGQ/D,KAAKN,EAAKC,EAAOC,GACvDqE,EAAO5D,EAAMkD,EAAIpD,EAAKqD,EAAIrD,EAAK4D,EAAE,KAAK/D,KAAKN,EAAKC,EAAKC,EAAE,GACvDsE,EAAO7D,EAAMkD,EAAIpD,EAAKqD,EAAE,EAAErD,EAAK4D,KAAO/D,KAAKN,EAAKC,EAAE,EAAKC,GACvDuE,EAAO9D,EAAMkD,EAAIpD,EAAKqD,EAAE,EAAErD,EAAK4D,EAAE,KAAK/D,KAAKN,EAAKC,EAAE,EAAGC,EAAE,GACvDwE,EAAO/D,EAAMkD,EAAE,EAAEpD,EAAKqD,EAAIrD,EAAK4D,KAAO/D,KAAKN,EAAE,EAAKC,EAAKC,GACvDyE,EAAOhE,EAAMkD,EAAE,EAAEpD,EAAKqD,EAAIrD,EAAK4D,EAAE,KAAK/D,KAAKN,EAAE,EAAKC,EAAGC,EAAE,GACvD0E,EAAOjE,EAAMkD,EAAE,EAAEpD,EAAKqD,EAAE,EAAErD,EAAK4D,KAAO/D,KAAKN,EAAE,EAAGC,EAAE,EAAKC,GACvD2E,EAAOlE,EAAMkD,EAAE,EAAEpD,EAAKqD,EAAE,EAAErD,EAAK4D,EAAE,KAAK/D,KAAKN,EAAE,EAAGC,EAAE,EAAGC,EAAE,GAGvDiE,EAAI9C,EAAKrB,GACTgB,EAAIK,EAAKpB,GACT6E,EAAIzD,EAAKnB,GAGb,OAAOqB,EACHA,EACAA,EAAK+C,EAAMI,EAAMP,GACjB5C,EAAKgD,EAAMI,EAAMR,GAAIW,GACrBvD,EACAA,EAAKiD,EAAMI,EAAMT,GACjB5C,EAAKkD,EAAMI,EAAMV,GAAIW,GACrB9D,IAGR+D,EAAOC,QAAUlF,G,kKChTV,SAASmF,EAAT,GAcH,IAbAC,EAaD,EAbCA,SACAC,EAYD,EAZCA,SAYD,IAXCC,KACIC,EAUL,EAVKA,MACAC,EASL,EATKA,OACAC,EAQL,EARKA,IAEJC,EAMD,EANCA,OACAC,EAKD,EALCA,YAKD,IAJCC,KACIC,EAGL,EAHKA,KACAC,EAEL,EAFKA,OAGEC,EAAOC,mBACTxE,EAAIqE,EAFT,EAIsCI,mBAAQ,WAGzC,IAFA,IAAIC,EAAY,GAAIC,EAAS,GAAIC,EAAU,GAElCC,EAAK,EAAGA,EAAKb,EAAQa,IAC1B,IAAK,IAAIC,EAAK,EAAGA,EAAKf,EAAOe,IAAM,CAC/B,IAAIpG,EAAIuF,GAAOa,GAAMf,EAAQ,GAAM,GAC/BpF,EAAIsF,GAAOY,GAAMb,EAAS,GAAM,GAChCpF,EAAIsF,EAAOxF,EAAGC,EAAGqB,GACrB0E,EAAUK,KAAKrG,EAAGC,EAAGC,GAErB,IAAIoG,EAAQb,EAAYzF,EAAGC,EAAGC,EAAGoB,GACjC2E,EAAOI,KAAKC,EAAMC,EAAGD,EAAME,EAAGF,EAAM7E,GAEpCyE,EAAQG,KAAK,EAAG,EAAG,GAO3B,MAAO,CACHL,UALJA,EAAY,IAAIS,aAAaT,GAMzBC,OALJA,EAAS,IAAIQ,aAAaR,GAMtBC,QALJA,EAAU,IAAIO,aAAaP,MAO5B,CAACb,EAAOC,EAAQC,EAAKC,EAAQC,EAAanE,IAzBvC0E,EAJP,EAIOA,UAAWC,EAJlB,EAIkBA,OAAQC,EAJ1B,EAI0BA,QA2BrBQ,EAAUX,mBAAQ,WAGlB,IAFA,IAAIW,EAAU,GACV3F,EAAI,EACCoF,EAAK,EAAGA,EAAKb,EAAS,EAAGa,IAAM,CACpC,IAAK,IAAIC,EAAK,EAAGA,EAAKf,EAAQ,EAAGe,IAC7BM,EAAQL,KAAKtF,EAAGA,EAAI,EAAGA,EAAIsE,EAAQ,GACnCqB,EAAQL,KAAKtF,EAAIsE,EAAQ,EAAGtE,EAAIsE,EAAOtE,GACvCA,IAEJA,IAEJ,OAAO,IAAI4F,YAAYD,KACxB,CAACrB,EAAOC,IAEPsB,EAASd,mBAAUe,EAAWf,mBAuBlC,OAtBAgB,aAAS,WACLxF,EAAIsE,EAAOtE,GAKX,IAHA,IAAM0E,EAAYY,EAAOG,QAAQC,MAAOf,EAASY,EAASE,QAAQC,MAE9DjG,EAAI,EACCoF,EAAK,EAAGA,EAAKb,EAAQa,IAC1B,IAAK,IAAIC,EAAK,EAAGA,EAAKf,EAAOe,IAAM,CAC/BJ,EAAUjF,EAAI,GAAKyE,EAAOQ,EAAUjF,GAAIiF,EAAUjF,EAAI,GAAIO,GAE1D,IAAI2F,EAAIxB,EAAYO,EAAUjF,GAAIiF,EAAUjF,EAAI,GAAIiF,EAAUjF,EAAI,GAAIO,GACtE2E,EAAOlF,GAAKkG,EAAEV,EACdN,EAAOlF,EAAI,GAAKkG,EAAET,EAClBP,EAAOlF,EAAI,GAAKkG,EAAExF,EAClBV,GAAK,EAIb6F,EAAOG,QAAQG,aAAc,EAC7BL,EAASE,QAAQG,aAAc,KAI/B,mCACI,uBACIC,IAAKtB,EACLX,SAAUA,EACVC,SAAUA,EAHd,UAKI,2CACI,iCACIgC,IAAKP,EACLQ,aAAc,CAAC,aAAc,YAC7BJ,MAAOhB,EACPqB,MAAOrB,EAAUsB,OAAS,EAC1BC,SAAU,IAEd,iCACIJ,IAAKN,EACLO,aAAc,CAAC,aAAc,SAC7BJ,MAAOf,EACPoB,MAAOpB,EAAOqB,OAAS,EACvBC,SAAU,IAEd,iCACIH,aAAc,CAAC,aAAc,UAC7BJ,MAAOd,EACPmB,MAAOnB,EAAQoB,OAAS,EACxBC,SAAU,IAEd,iCACIC,OAAO,QACPR,MAAON,EACPW,MAAOX,EAAQY,OACfC,SAAU,OAGlB,sCACIE,cAAY,EACZC,KAAMC,oB,qBClDnB,SAASC,EAAT,GAA0C,IAAvB1C,EAAsB,EAAtBA,SAAUC,EAAY,EAAZA,SAC5BvE,EAAOC,KAAKC,MAAMD,KAAKgH,SAALhH,KAAA,IAAiB,EAAK,KAC9Cf,IAAMc,KAAKA,GA0CX,OACE,cAACqE,EAAD,CACEC,SAAUA,EACVC,SAAUA,EACVC,KAAM,CACJC,MAAO,IACPC,OAAQ,IACRC,IAAK,IAEPC,OA9BW,SAACxF,EAAGC,EAAGqB,GACpB,OApBkB,SAACtB,EAAGC,EAAGC,GAUzB,IATA,IAKI4H,EAAM,EACNC,EAAO,EAEP/G,EAAI,EACCD,EAAI,EAAGA,EARF,GAQeA,IAC3BC,GAAK8G,EAAM1D,kBAAQpE,EAAI+H,EAVb,KAU2B9H,EAAI8H,EAV/B,KAU6C7H,GACvD4H,GATgB,GAUhBC,GATe,EAYjB,OAAO/G,EAIAgH,CAAYhI,EAAGC,EAAGqB,IA8BvBmE,YA3BgB,SAACzF,EAAGC,EAAGC,EAAGoB,GAC5B,IAAM2G,ECrFH,WAAwC,IAArBrH,EAAoB,uDAAbC,KAAKqH,GAAK,EAEvC,OAAO,WACH,IAAMlI,EAAuB,IAAnBa,KAAKsH,IAAIvH,KACnB,OAAOZ,EAAIa,KAAKC,MAAMd,IDiFNoI,CAAU,KAAKpI,EAAE,EAAEC,EAAEW,GACnCyH,EAAY,WAChB,MAAqB,IAAdJ,KAGT,MAAO,CACL1B,EAAGrG,EAAImI,IACP7B,EAAGtG,EAAI,EAAImI,IACX5G,EAAGZ,KAAKK,KAAK,SAAAlB,EAAK,GAAL,SAASC,EAAK,IAAK,GAAKoI,MAmBrC3C,KAAM,CACJC,KAAM,EACNC,OAjBS,SAACtE,GACd,OAAOA,EAAI,SElHf,ICsBegH,EApBL,2HCFS,4sEDET,uPEGGC,EAAgB,SAAC,GAEvB,IADHrD,EACE,EADFA,SAAUC,EACR,EADQA,SACR,IADkBqD,iBAClB,SACIC,EAAU3C,mBAEhBgB,aAAS,YAAgB,IAAb4B,EAAY,EAAZA,MACRD,EAAQ1B,QAAQ4B,SAASC,SAASC,OAAOC,MAAsB,KAAdJ,EAAMK,WAS3D,OACI,uBAAM7D,SAAUA,EAAUC,SAAUA,EAAUgC,IAAKsB,EAAnD,UACI,6BAAaO,KAAM,CAAC,EAAG,EAAG,EAAG,GAAI,GAAI,MACrC,gCACIxB,OAAO,WACPoB,SAXG,CACXC,OAAQ,CAAEI,KAAM,IAAKH,MAAO,GAC5BI,IAAK,CAACD,KAAM,IAAKH,MAAO,IAUhBK,aAAcb,EACdc,eH3BN,mUG4BMZ,UAAWA,QCnB3B,SAASa,IAAkB,IAAD,EAIpBC,cAFFC,EAFsB,EAEtBA,OACMC,EAHgB,EAGtBC,GAAMD,WAGFE,EAAc5D,mBAGpB,OAFAgB,aAAS,kBAAM4C,EAAY3C,QAAQnB,YAGjC,+BACEuB,IAAKuC,EACLV,KAAM,CAACO,EAAQC,KAOrB,SAASG,IACP,OACE,eAAC,IAAD,CACEC,iBAAe,EACfL,OAAQ,CAAErE,SAAU,CAAC,EAAG,EAAG,IAAK2E,IAAK,IAFvC,UAIE,iCAGA,eAAC,WAAD,CAAUC,SAAU,KAApB,UAGE,cAAClC,EAAD,CAAS1C,SAAU,CAAC,EAAE,EAAE,GAAIC,SAAU,EAAEtE,KAAKqH,GAAG,EAAE,EAAE,KACpD,cAAC,EAAD,CAAehD,SAAU,EAAE,EAAG,IAAK,GAAIC,SAAU,CAAC,EAAG,EAAG,GAAIqD,WAAS,IACrE,cAAC,EAAD,CAAetD,SAAU,CAAC,EAAG,IAAK,GAAIC,SAAU,CAAC,EAAG,EAAG,QAEzD,cAACkE,EAAD,OArCNU,YAAO,CAAEC,oBAyDMC,MAff,WACE,OACE,sBAAKC,UAAU,MAAf,UACE,qBAAKA,UAAU,OAAf,SACE,cAAC,WAAD,CAAUJ,SAAU,6CAApB,SACE,cAACH,EAAD,QAGJ,mBAAGO,UAAU,QAAQC,KAAK,wDAAwDC,IAAI,eAAtF,SACE,qBAAKC,IAAI,+EAA+ED,IAAI,WC9CrFE,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCDdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1Bb,M","file":"static/js/main.e2a08b85.chunk.js","sourcesContent":["/*\n * A speed-improved perlin and simplex noise algorithms for 2D.\n *\n * Based on example code by Stefan Gustavson (stegu@itn.liu.se).\n * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\n * Better rank ordering method by Stefan Gustavson in 2012.\n * Converted to Javascript by Joseph Gentle.\n *\n * Version 2012-03-09\n *\n * This code was placed in the public domain by its original author,\n * Stefan Gustavson. You may use it as you see fit, but\n * attribution is appreciated.\n *\n */\n\nlet noise = {}\n\nfunction Grad(x, y, z) {\n    this.x = x; this.y = y; this.z = z;\n}\n\nGrad.prototype.dot2 = function(x, y) {\n    return this.x*x + this.y*y;\n};\n\nGrad.prototype.dot3 = function(x, y, z) {\n    return this.x*x + this.y*y + this.z*z;\n};\n\nvar grad3 = [new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),\n                new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),\n                new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)];\n\nvar p = [151,160,137,91,90,15,\n131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];\n// To remove the need for index wrapping, double the permutation table length\nvar perm = new Array(512);\nvar gradP = new Array(512);\n\n// This isn't a very good seeding function, but it works ok. It supports 2^16\n// different seed values. Write something better if you need more seeds.\nnoise.seed = function(seed) {\n    if(seed > 0 && seed < 1) {\n    // Scale the seed out\n    seed *= 65536;\n    }\n\n    seed = Math.floor(seed);\n    if(seed < 256) {\n    seed |= seed << 8;\n    }\n\n    for(var i = 0; i < 256; i++) {\n    var v;\n    if (i & 1) {\n        v = p[i] ^ (seed & 255);\n    } else {\n        v = p[i] ^ ((seed>>8) & 255);\n    }\n\n    perm[i] = perm[i + 256] = v;\n    gradP[i] = gradP[i + 256] = grad3[v % 12];\n    }\n};\n\nnoise.seed(0);\n\n/*\nfor(var i=0; i<256; i++) {\n    perm[i] = perm[i + 256] = p[i];\n    gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];\n}*/\n\n// Skewing and unskewing factors for 2, 3, and 4 dimensions\nvar F2 = 0.5*(Math.sqrt(3)-1);\nvar G2 = (3-Math.sqrt(3))/6;\n\nvar F3 = 1/3;\nvar G3 = 1/6;\n\n// 2D simplex noise\nnoise.simplex2 = function(xin, yin) {\n    var n0, n1, n2; // Noise contributions from the three corners\n    // Skew the input space to determine which simplex cell we're in\n    var s = (xin+yin)*F2; // Hairy factor for 2D\n    var i = Math.floor(xin+s);\n    var j = Math.floor(yin+s);\n    var t = (i+j)*G2;\n    var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.\n    var y0 = yin-j+t;\n    // For the 2D case, the simplex shape is an equilateral triangle.\n    // Determine which simplex we are in.\n    var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n    if(x0>y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n    i1=1; j1=0;\n    } else {    // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n    i1=0; j1=1;\n    }\n    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n    // c = (3-sqrt(3))/6\n    var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n    var y1 = y0 - j1 + G2;\n    var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\n    var y2 = y0 - 1 + 2 * G2;\n    // Work out the hashed gradient indices of the three simplex corners\n    i &= 255;\n    j &= 255;\n    var gi0 = gradP[i+perm[j]];\n    var gi1 = gradP[i+i1+perm[j+j1]];\n    var gi2 = gradP[i+1+perm[j+1]];\n    // Calculate the contribution from the three corners\n    var t0 = 0.5 - x0*x0-y0*y0;\n    if(t0<0) {\n    n0 = 0;\n    } else {\n    t0 *= t0;\n    n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient\n    }\n    var t1 = 0.5 - x1*x1-y1*y1;\n    if(t1<0) {\n    n1 = 0;\n    } else {\n    t1 *= t1;\n    n1 = t1 * t1 * gi1.dot2(x1, y1);\n    }\n    var t2 = 0.5 - x2*x2-y2*y2;\n    if(t2<0) {\n    n2 = 0;\n    } else {\n    t2 *= t2;\n    n2 = t2 * t2 * gi2.dot2(x2, y2);\n    }\n    // Add contributions from each corner to get the final noise value.\n    // The result is scaled to return values in the interval [-1,1].\n    return 70 * (n0 + n1 + n2);\n};\n\n// 3D simplex noise\nnoise.simplex3 = function(xin, yin, zin) {\n    var n0, n1, n2, n3; // Noise contributions from the four corners\n\n    // Skew the input space to determine which simplex cell we're in\n    var s = (xin+yin+zin)*F3; // Hairy factor for 2D\n    var i = Math.floor(xin+s);\n    var j = Math.floor(yin+s);\n    var k = Math.floor(zin+s);\n\n    var t = (i+j+k)*G3;\n    var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.\n    var y0 = yin-j+t;\n    var z0 = zin-k+t;\n\n    // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n    // Determine which simplex we are in.\n    var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n    var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n    if(x0 >= y0) {\n    if(y0 >= z0)      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }\n    else if(x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }\n    else              { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }\n    } else {\n    if(y0 < z0)      { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }\n    else if(x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }\n    else             { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }\n    }\n    // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n    // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n    // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n    // c = 1/6.\n    var x1 = x0 - i1 + G3; // Offsets for second corner\n    var y1 = y0 - j1 + G3;\n    var z1 = z0 - k1 + G3;\n\n    var x2 = x0 - i2 + 2 * G3; // Offsets for third corner\n    var y2 = y0 - j2 + 2 * G3;\n    var z2 = z0 - k2 + 2 * G3;\n\n    var x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner\n    var y3 = y0 - 1 + 3 * G3;\n    var z3 = z0 - 1 + 3 * G3;\n\n    // Work out the hashed gradient indices of the four simplex corners\n    i &= 255;\n    j &= 255;\n    k &= 255;\n    var gi0 = gradP[i+   perm[j+   perm[k   ]]];\n    var gi1 = gradP[i+i1+perm[j+j1+perm[k+k1]]];\n    var gi2 = gradP[i+i2+perm[j+j2+perm[k+k2]]];\n    var gi3 = gradP[i+ 1+perm[j+ 1+perm[k+ 1]]];\n\n    // Calculate the contribution from the four corners\n    var t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;\n    if(t0<0) {\n    n0 = 0;\n    } else {\n    t0 *= t0;\n    n0 = t0 * t0 * gi0.dot3(x0, y0, z0);  // (x,y) of grad3 used for 2D gradient\n    }\n    var t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;\n    if(t1<0) {\n    n1 = 0;\n    } else {\n    t1 *= t1;\n    n1 = t1 * t1 * gi1.dot3(x1, y1, z1);\n    }\n    var t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;\n    if(t2<0) {\n    n2 = 0;\n    } else {\n    t2 *= t2;\n    n2 = t2 * t2 * gi2.dot3(x2, y2, z2);\n    }\n    var t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;\n    if(t3<0) {\n    n3 = 0;\n    } else {\n    t3 *= t3;\n    n3 = t3 * t3 * gi3.dot3(x3, y3, z3);\n    }\n    // Add contributions from each corner to get the final noise value.\n    // The result is scaled to return values in the interval [-1,1].\n    return 32 * (n0 + n1 + n2 + n3);\n\n};\n\n// ##### Perlin noise stuff\n\nfunction fade(t) {\n    return t*t*t*(t*(t*6-15)+10);\n}\n\nfunction lerp(a, b, t) {\n    return (1-t)*a + t*b;\n}\n\n// 2D Perlin Noise\nnoise.perlin2 = function(x, y) {\n    // Find unit grid cell containing point\n    var X = Math.floor(x), Y = Math.floor(y);\n    // Get relative xy coordinates of point within that cell\n    x = x - X; y = y - Y;\n    // Wrap the integer cells at 255 (smaller integer period can be introduced here)\n    X = X & 255; Y = Y & 255;\n\n    // Calculate noise contributions from each of the four corners\n    var n00 = gradP[X+perm[Y]].dot2(x, y);\n    var n01 = gradP[X+perm[Y+1]].dot2(x, y-1);\n    var n10 = gradP[X+1+perm[Y]].dot2(x-1, y);\n    var n11 = gradP[X+1+perm[Y+1]].dot2(x-1, y-1);\n\n    // Compute the fade curve value for x\n    var u = fade(x);\n\n    // Interpolate the four results\n    return lerp(\n        lerp(n00, n10, u),\n        lerp(n01, n11, u),\n        fade(y));\n};\n\n// 3D Perlin Noise\nnoise.perlin3 = function(x, y, z) {\n    // Find unit grid cell containing point\n    var X = Math.floor(x), Y = Math.floor(y), Z = Math.floor(z);\n    // Get relative xyz coordinates of point within that cell\n    x = x - X; y = y - Y; z = z - Z;\n    // Wrap the integer cells at 255 (smaller integer period can be introduced here)\n    X = X & 255; Y = Y & 255; Z = Z & 255;\n\n    // Calculate noise contributions from each of the eight corners\n    var n000 = gradP[X+  perm[Y+  perm[Z  ]]].dot3(x,   y,     z);\n    var n001 = gradP[X+  perm[Y+  perm[Z+1]]].dot3(x,   y,   z-1);\n    var n010 = gradP[X+  perm[Y+1+perm[Z  ]]].dot3(x,   y-1,   z);\n    var n011 = gradP[X+  perm[Y+1+perm[Z+1]]].dot3(x,   y-1, z-1);\n    var n100 = gradP[X+1+perm[Y+  perm[Z  ]]].dot3(x-1,   y,   z);\n    var n101 = gradP[X+1+perm[Y+  perm[Z+1]]].dot3(x-1,   y, z-1);\n    var n110 = gradP[X+1+perm[Y+1+perm[Z  ]]].dot3(x-1, y-1,   z);\n    var n111 = gradP[X+1+perm[Y+1+perm[Z+1]]].dot3(x-1, y-1, z-1);\n\n    // Compute the fade curve value for x, y, z\n    var u = fade(x);\n    var v = fade(y);\n    var w = fade(z);\n\n    // Interpolate\n    return lerp(\n        lerp(\n        lerp(n000, n100, u),\n        lerp(n001, n101, u), w),\n        lerp(\n        lerp(n010, n110, u),\n        lerp(n011, n111, u), w),\n        v);\n};\n\nmodule.exports = noise","import { useFrame } from \"@react-three/fiber\";\nimport { useMemo, useRef } from \"react\";\nimport * as THREE from 'three';\n\nexport function MeshAnim({\n    position,\n    rotation,\n    grid: {\n        width,\n        height,\n        sep\n    },\n    zOfXYT,\n    colorOfXYZT,\n    anim: {\n        init,\n        update\n    }\n}) {\n    const mesh = useRef()\n    let t = init;\n\n    let { positions, colors, normals } = useMemo(() => {\n        let positions = [], colors = [], normals = []\n\n        for (let yi = 0; yi < height; yi++) {\n            for (let xi = 0; xi < width; xi++) {\n                let x = sep * (xi - (width - 1.) / 2.)\n                let y = sep * (yi - (height + 1.) / 2.)\n                let z = zOfXYT(x, y, t)\n                positions.push(x, y, z)\n\n                let color = colorOfXYZT(x, y, z, t)\n                colors.push(color.r, color.g, color.b)\n                \n                normals.push(0, 0, 1)\n            }\n        }\n        positions = new Float32Array(positions)\n        colors = new Float32Array(colors)\n        normals = new Float32Array(normals)\n\n        return {\n            positions,\n            colors,\n            normals\n        }\n    }, [width, height, sep, zOfXYT, colorOfXYZT, t])\n\n    let indices = useMemo(() => {\n        let indices = []\n        let i = 0\n        for (let yi = 0; yi < height - 1; yi++) {\n            for (let xi = 0; xi < width - 1; xi++) {\n                indices.push(i, i + 1, i + width + 1)\n                indices.push(i + width + 1, i + width, i)\n                i++\n            }\n            i++\n        }\n        return new Uint16Array(indices)\n    }, [width, height])\n\n    let posRef = useRef(), colorRef = useRef()\n    useFrame(() => {\n        t = update(t)\n\n        const positions = posRef.current.array, colors = colorRef.current.array;\n\n        let i = 0\n        for (let yi = 0; yi < height; yi++) {\n            for (let xi = 0; xi < width; xi++) {\n                positions[i + 2] = zOfXYT(positions[i], positions[i + 1], t)\n\n                let c = colorOfXYZT(positions[i], positions[i + 1], positions[i + 2], t)\n                colors[i] = c.r\n                colors[i + 1] = c.g\n                colors[i + 2] = c.b\n                i += 3\n            }\n        }\n\n        posRef.current.needsUpdate = true;\n        colorRef.current.needsUpdate = true;\n    })\n\n    return (\n        <>\n            <mesh\n                ref={mesh}\n                position={position}\n                rotation={rotation}\n            >\n                <bufferGeometry>\n                    <bufferAttribute\n                        ref={posRef}\n                        attachObject={['attributes', 'position']}\n                        array={positions}\n                        count={positions.length / 3}\n                        itemSize={3}\n                    />\n                    <bufferAttribute\n                        ref={colorRef}\n                        attachObject={['attributes', 'color']}\n                        array={colors}\n                        count={colors.length / 3}\n                        itemSize={3}\n                    />\n                    <bufferAttribute\n                        attachObject={['attributes', 'normal']}\n                        array={normals}\n                        count={normals.length / 3}\n                        itemSize={3}\n                    />\n                    <bufferAttribute\n                        attach=\"index\"\n                        array={indices}\n                        count={indices.length}\n                        itemSize={1}\n                    />\n                </bufferGeometry>\n                <meshStandardMaterial\n                    vertexColors\n                    side={THREE.DoubleSide}\n                />\n            </mesh>\n\n        </>\n    );\n}","import { MeshAnim } from \"./MeshAnim\";\nimport noise, { perlin3 } from \"./noise\";\nimport { randomSin } from './math';\n\nexport function GrowingExp({ position }) {\n  const zOfXYT = (x, y, t) => {\n    let cyc = 1 + Math.sin(t / 250)\n\n    return cyc *\n      5 * Math.exp(-1 * (x ** 2 + y ** 2) ** (0.75) / cyc);\n  }\n\n  const colorOfXYZT = (x, y, z, t) => {\n    let r = Math.sqrt(x ** 2 + y ** 2)\n\n    return {\n      b: r / 75,\n      g: z / 5,\n      r: z\n    }\n  }\n\n  return (\n    <MeshAnim\n      position={position}\n      rotation={[-Math.PI / 2, 0, 0]}\n      grid={{\n        width: 100,\n        height: 100,\n        sep: 0.1\n      }}\n      zOfXYT={zOfXYT}\n      colorOfXYZT={colorOfXYZT}\n      anim={{\n        init: 0,\n        update: (t) => {\n          return t + 1\n        }\n      }}\n    />\n  );\n}\n\nexport function Ripple({ position }) {\n  const zOfXYT = (x, y, t) => {\n    return Math.sin(0.1 * (x ** 2 + y ** 2 + t));\n  }\n\n  const colorOfXYZT = (x, y, z, t) => {\n    return [0.2 * Math.cos(z), z / 5, 0.2] // r, g, b\n  }\n\n  return (\n    <MeshAnim\n      position={position}\n      grid={{\n        width: 100,\n        height: 100,\n        sep: 0.1\n      }}\n      zOfXYT={zOfXYT}\n      colorOfXYZT={colorOfXYZT}\n      anim={{\n        init: 0,\n        update: (t) => {\n          return t + 0.1\n        }\n      }}\n    />\n  );\n\n}\n\nexport function Terrain({ position, rotation }) {\n  const seed = Math.floor(Math.random() * (2 ** 16))\n  noise.seed(seed)\n\n  const sampleNoise = (x, y, z) => {\n    let scale = 1 / 8\n    let octaves = 20\n    let persistence = 0.6\n    let lacunarity = 2\n\n    let amp = 1\n    let freq = 1\n\n    let v = 0\n    for (let i = 0; i < octaves; i++) {\n      v += amp * perlin3(x * freq * scale, y * freq * scale, z)\n      amp *= persistence\n      freq *= lacunarity\n    }\n\n    return v\n  }\n\n  const zOfXYT = (x, y, t) => {\n    return sampleNoise(x, y, t);\n  }\n\n  const colorOfXYZT = (x, y, z, t) => {\n    const localRandom = randomSin(1001*x-7*y+seed)\n    const variation = () => {\n      return localRandom()*0.01;\n    }\n\n    return {\n      r: z + variation(),\n      g: z / 5 + variation(),\n      b: Math.sqrt(x ** 2 + y ** 2) / 75 + variation(),\n    }\n  }\n\n  const update = (t) => {\n    return t + .002\n  }\n\n  return (\n    <MeshAnim\n      position={position}\n      rotation={rotation}\n      grid={{\n        width: 100,\n        height: 100,\n        sep: .2\n      }}\n      zOfXYT={zOfXYT}\n      colorOfXYZT={colorOfXYZT}\n      anim={{\n        init: 0,\n        update\n      }}\n    />\n  );\n}\n\n","export function lerp(x, y, a) {\n    return (1 - a) * x + a * y\n}\n\nexport function clamp(x, min, max) {\n   return Math.min(Math.max(x, min), max)\n}\n\nexport function randomRange(lb, ub, rng){\n    if(ub < lb){\n        throw Error(\"upper bound has to be greater than lower bound\")\n    }\n\n    return rng()*(ub-lb)+lb\n}\n\nexport function randomSin(seed = Math.PI / 4) { // ~3.4 million b4 repeat.\n    // https://stackoverflow.com/a/19303725/1791917\n    return () => {\n        const x = Math.sin(seed++) * 10000\n        return x - Math.floor(x)\n    }\n}\n","const frag = \n`\nprecision mediump float;\n\nvarying vec2 vUv;\nvarying vec3 pos;\n\nuniform float u_time;\n\nvoid main() {\n    // colour is RGBA: u, v, 0, 1\n    float r = 5.*(length(pos)-0.5);\n    // r = 5.*(pos.x/2.+0.5); // pos.x [0, 1]\n\n    gl_FragColor = vec4(pos/2.+0.5, 1. );\n    gl_FragColor = vec4(r, r/5., 0., 1.);\n}\n`\n\nexport default frag","import { random } from \"./lib\";\n\nconst vert = \n`\nprecision mediump float;\nvarying vec2 vUv;\nvarying vec3 pos;\n\nuniform float u_time;\nuniform float rad;\n\n${random}\n\nvoid main() {\n    vUv = uv;\n    vec3 dir = position/length(position);\n    vec3 trans = dir*rad-0.2*simplex3d(vec3(dir.xy, u_time/2.))*dir;\n    pos = trans;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(trans, 1.0 );\n}\n`\n\nexport default vert;","export const random = `\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n/* const matrices for 3d rotation */\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\n/* directional artifacts can be reduced by rotating each octave */\nfloat simplex3d_fractal(vec3 m) {\n    return   0.5333333*simplex3d(m*rot1)\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n`","import { useFrame } from \"@react-three/fiber\";\nimport { useRef } from \"react\";\nimport frag from \"./shader/frag\";\nimport vert from \"./shader/vert\";\n\nexport const TerrainSphere = ({\n    position, rotation, wireframe=false\n}) => {\n    const meshRef = useRef();\n\n    useFrame(({ clock }) => {\n        meshRef.current.material.uniforms.u_time.value = clock.oldTime*0.001;\n    });\n\n    let uniforms = {\n        u_time: { type: 'f', value: 0 },\n        rad: {type: 'f', value: 1}\n    }\n\n    // create cube sphere with custom shader\n    return (\n        <mesh position={position} rotation={rotation} ref={meshRef}>\n            <boxGeometry args={[1, 1, 1, 10, 10, 10]} /> \n            <shaderMaterial\n                attach=\"material\"\n                uniforms={uniforms}\n                vertexShader={vert}\n                fragmentShader={frag}\n                wireframe={wireframe}\n            />\n        </mesh>\n    );\n}\n","import './App.scss';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\nimport { Canvas, extend, useFrame, useThree } from '@react-three/fiber';\nimport { Suspense, useRef } from 'react';\nimport { Terrain } from './components/Anims';\nimport { TerrainSphere } from './components/TerrainSphere/TerrainSphere';\n\nextend({ OrbitControls })\n\nfunction CameraControls() {\n  const {\n    camera,\n    gl: { domElement }\n  } = useThree();\n\n  const controlsRef = useRef();\n  useFrame(() => controlsRef.current.update())\n\n  return (\n    <orbitControls\n      ref={controlsRef}\n      args={[camera, domElement]}\n    // autoRotate\n    // autoRotateSpeed={0.2}\n    />\n  );\n}\n\nfunction AnimationCanvas() {\n  return (\n    <Canvas\n      colorManagement\n      camera={{ position: [0, 2, 10], fov: 75 }}\n    >\n      <ambientLight/>\n      {/* <hemisphereLight/> */}\n      {/* <directionalLight /> */}\n      <Suspense fallback={null}>\n        {/* <GrowingExp position={[0, -0.5, 0]}/> */}\n        {/* <Ripple position={[25, 0, 0]}/> */}\n        <Terrain position={[0,0,0]} rotation={[-Math.PI/2,0,0]}/>\n        <TerrainSphere position={[-2, 2.5, 0]} rotation={[0, 0, 0]} wireframe />\n        <TerrainSphere position={[2, 2.5, 0]} rotation={[0, 0, 0]} />\n      </Suspense>\n      <CameraControls />\n    </Canvas>\n  );\n}\n\nfunction App() {\n  return (\n    <div className=\"app\">\n      <div className=\"anim\">\n        <Suspense fallback={<div>Loading...</div>}>\n          <AnimationCanvas />\n        </Suspense>\n      </div>\n      <a className=\"badge\" href=\"https://github.com/claeb101/procedural-mesh-animation\" alt=\"Contributors\">\n        <img src=\"https://img.shields.io/github/last-commit/claeb101/procedural-mesh-animation\" alt=\"\"/>\n      </a>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}